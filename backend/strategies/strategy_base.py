import pandas as pd
import numpy as np
import logging
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional

from shared_types import TradingSignalModel, AssetSymbol, Timeframe

# Configure logging
logger = logging.getLogger(__name__)

class StrategyBase(ABC):
    """
    Base class for all trading strategies.
    
    All custom strategies generated by the DSL parser will inherit from this class.
    """
    
    def __init__(self, name: str):
        """
        Initialize the strategy with a name.
        
        Args:
            name: Name of the strategy
        """
        self.name = name
        logger.info(f"Initialized strategy: {name}")
    
    @abstractmethod
    def generate_signals(self, df: pd.DataFrame, asset: AssetSymbol, timeframe: Timeframe) -> List[TradingSignalModel]:
        """
        Generate trading signals based on the strategy rules.
        
        Args:
            df: DataFrame containing market data
            asset: Asset symbol to generate signals for
            timeframe: Timeframe to generate signals for
            
        Returns:
            List of TradingSignalModel instances
        """
        pass
    
    def preprocess_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Preprocess data before generating signals.
        
        This method can be overridden by subclasses to add custom preprocessing.
        
        Args:
            df: DataFrame containing market data
            
        Returns:
            Preprocessed DataFrame
        """
        # Make a copy to avoid modifying the original dataframe
        df = df.copy()
        
        # Ensure datetime index
        if not isinstance(df.index, pd.DatetimeIndex):
            df.set_index('timestamp', inplace=True)
            
        # Ensure all required columns are available
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        for col in required_columns:
            if col not in df.columns:
                logger.error(f"Required column '{col}' missing from data")
                raise ValueError(f"Required column '{col}' missing from data")
        
        # Remove NaN values
        df.dropna(inplace=True)
        
        return df
    
    def __str__(self) -> str:
        """String representation of the strategy"""
        return f"Strategy(name={self.name})"
