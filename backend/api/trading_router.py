from fastapi import APIRouter, HTTPException, Path, Depends, Request
from typing import List, Dict, Any
import logging

from shared_types import AssetSymbol, Timeframe, TradingSignalModel, SignalType
from backend.agents import MarketDataAgent, SignalScannerAgent, RiskManagerAgent, JournalAgent
from backend.core.security import get_current_user
from backend.models.user import User, SubscriptionTier
from backend.core.middleware import requires_feature, is_feature_accessible, get_tier_limit

logger = logging.getLogger(__name__)

router = APIRouter()

# Instantiate agents globally for this router instance
# In a production setup, consider dependency injection (e.g., FastAPI's Depends)
# and more sophisticated configuration management for agent parameters.
market_agent = MarketDataAgent()
scanner_agent = SignalScannerAgent(market_data_agent=market_agent)
# Instantiate JournalAgent - default path is 'trading_journal.sqlite' in the CWD of the app
journal_agent = JournalAgent() 

# RiskManagerAgent can be configured with parameters from .env or a config file later
risk_agent = RiskManagerAgent(
    account_balance_usd=1000.0,      # Example: Default or from config
    max_risk_per_trade_pct=0.01,   # Example: 1% risk
    min_reward_to_risk_ratio=1.5,
    journal_agent=journal_agent      # Pass journal_agent instance
)

@router.get(
    "/scan/{asset_str}/{timeframe_str}", 
    response_model=List[TradingSignalModel],
    summary="Scan for trading signals for a specific asset and timeframe",
    tags=["Trading Signals"]
)
async def scan_signals_for_asset(
    asset_str: str = Path(..., description="Asset symbol string (e.g., 'BTC-USD', 'SPY')"),
    timeframe_str: str = Path(..., description="Timeframe string (e.g., '1h', '15m')"),
    current_user: User = Depends(get_current_user)  # Add authentication dependency
):
    """
    Scans for trading signals for a given asset and timeframe using the integrated agent pipeline:
    1. Fetches market data using MarketDataAgent.
    2. Generates raw signals using SignalScannerAgent.
    3. Filters and approves signals using RiskManagerAgent.
    
    Returns a list of approved trading signals.
    """
    try:
        normalized_asset_str = asset_str.upper()
        # For EURUSD=X, the enum value is 'EURUSD=X', so direct mapping works.
        # If there was a case like 'EUR_USD_FX' in URL mapping to 'EURUSD=X' enum, then special logic is needed.
        # Current AssetSymbol enum values are designed to match common ticker formats directly.
        asset = AssetSymbol(normalized_asset_str) 
    except ValueError:
        logger.error(f"Invalid asset string: {asset_str} (normalized: {normalized_asset_str if 'normalized_asset_str' in locals() else 'N/A'})")
        raise HTTPException(status_code=400, detail=f"Invalid asset symbol: {asset_str}. Supported: {', '.join([e.value for e in AssetSymbol])}")

    try:
        # Normalize timeframe string, e.g., '5M' to '5m'
        timeframe_processed_str = timeframe_str.lower()
        if 'min' in timeframe_processed_str:
            timeframe_processed_str = timeframe_processed_str.replace('min', 'm')
        timeframe = Timeframe(timeframe_processed_str)
    except ValueError:
        logger.error(f"Invalid timeframe string: {timeframe_str}")
        raise HTTPException(status_code=400, detail=f"Invalid timeframe: {timeframe_str}. Supported: {', '.join([e.value for e in Timeframe])}")

    logger.info(f"Received scan request for Asset: {asset.value}, Timeframe: {timeframe.value}")

    # 1. Fetch market data
    historical_data = market_agent.fetch_historical_data(asset, timeframe)
    if not historical_data or not historical_data.candles:
        logger.warning(f"No market data found for {asset.value} {timeframe.value}. Returning empty list.")
        return []
    logger.info(f"Fetched {len(historical_data.candles)} candles for {asset.value} {timeframe.value}.")

    # 2. Scan for raw signals
    raw_signals = scanner_agent.scan_for_breakout_signals(asset, timeframe, historical_data=historical_data)
    if not raw_signals:
        logger.info(f"No raw signals generated by SignalScannerAgent for {asset.value} {timeframe.value}.")
        return []
    logger.info(f"Generated {len(raw_signals)} raw signals for {asset.value} {timeframe.value}.")

    # 3. Filter signals with RiskManagerAgent
    approved_signals = risk_agent.filter_signals(raw_signals)
    if not approved_signals:
        logger.info(f"No signals approved by RiskManagerAgent for {asset.value} {timeframe.value}.")
        return []
    
    logger.info(f"Returning {len(approved_signals)} approved signals for {asset.value} {timeframe.value}.")
    return approved_signals


@router.get(
    "/premium/signals/{asset_str}/{timeframe_str}",
    response_model=List[TradingSignalModel],
    summary="Premium endpoint: Get real-time signals with no delay",
    tags=["Premium Features"]
)
@requires_feature("real_time_signals")
async def premium_real_time_signals(
    asset_str: str = Path(..., description="Asset symbol string (e.g., 'BTC-USD', 'SPY')"),
    timeframe_str: str = Path(..., description="Timeframe string (e.g., '1h', '15m')"),
    current_user: User = Depends(get_current_user)
):
    """
    Premium endpoint that provides real-time signals with no delay.
    Requires a Pro or Enterprise subscription tier.
    
    Uses the same signal generation logic as the regular endpoint but without any delay.
    """
    try:
        normalized_asset_str = asset_str.upper()
        asset = AssetSymbol(normalized_asset_str) 
    except ValueError:
        logger.error(f"Invalid asset string: {asset_str}")
        raise HTTPException(status_code=400, detail=f"Invalid asset symbol: {asset_str}. Supported: {', '.join([e.value for e in AssetSymbol])}")

    try:
        timeframe_processed_str = timeframe_str.lower()
        if 'min' in timeframe_processed_str:
            timeframe_processed_str = timeframe_processed_str.replace('min', 'm')
        timeframe = Timeframe(timeframe_processed_str)
    except ValueError:
        logger.error(f"Invalid timeframe string: {timeframe_str}")
        raise HTTPException(status_code=400, detail=f"Invalid timeframe: {timeframe_str}. Supported: {', '.join([e.value for e in Timeframe])}")

    logger.info(f"[PREMIUM] Received real-time signal request for Asset: {asset.value}, Timeframe: {timeframe.value}")

    # 1. Fetch market data
    historical_data = market_agent.fetch_historical_data(asset, timeframe)
    if not historical_data or not historical_data.candles:
        logger.warning(f"No market data found for {asset.value} {timeframe.value}. Returning empty list.")
        return []
    logger.info(f"Fetched {len(historical_data.candles)} candles for {asset.value} {timeframe.value}.")

    # 2. Scan for raw signals
    raw_signals = scanner_agent.scan_for_breakout_signals(asset, timeframe, historical_data=historical_data)
    if not raw_signals:
        logger.info(f"No raw signals generated by SignalScannerAgent for {asset.value} {timeframe.value}.")
        return []
    logger.info(f"Generated {len(raw_signals)} raw signals for {asset.value} {timeframe.value}.")

    # 3. Filter signals with RiskManagerAgent
    approved_signals = risk_agent.filter_signals(raw_signals)
    if not approved_signals:
        logger.info(f"No signals approved by RiskManagerAgent for {asset.value} {timeframe.value}.")
        return []
    
    logger.info(f"[PREMIUM] Returning {len(approved_signals)} real-time signals for {asset.value} {timeframe.value}.")
    return approved_signals


@router.get(
    "/premium/asset-limits",
    response_model=Dict[str, Any],
    summary="Get asset limits based on subscription tier",
    tags=["Premium Features"]
)
async def get_asset_limits(current_user: User = Depends(get_current_user)):
    """
    Get the asset limits based on the user's subscription tier.
    This endpoint is accessible to all authenticated users but returns different limits based on tier.
    """
    # Get asset limit for the user's tier
    max_assets = await get_tier_limit(current_user, "max_assets")
    max_strategies = await get_tier_limit(current_user, "max_custom_strategies")
    max_signals = await get_tier_limit(current_user, "max_concurrent_signals")
    signal_delay = await get_tier_limit(current_user, "signal_delay_minutes")
    
    # Check feature access
    can_use_all_assets = is_feature_accessible(current_user, "all_assets")
    can_use_paper_trading = is_feature_accessible(current_user, "paper_trading")
    can_use_strategy_customization = is_feature_accessible(current_user, "strategy_customization")
    can_use_live_trading = is_feature_accessible(current_user, "live_trading")
    
    # Compile response
    return {
        "subscription_tier": current_user.subscription_tier,
        "limits": {
            "max_assets": max_assets,
            "max_custom_strategies": max_strategies,
            "max_concurrent_signals": max_signals,
            "signal_delay_minutes": signal_delay
        },
        "features": {
            "all_assets": can_use_all_assets,
            "paper_trading": can_use_paper_trading,
            "strategy_customization": can_use_strategy_customization,
            "live_trading": can_use_live_trading
        }
    }

# Example of how to add more endpoints or routers if needed
# health_router = APIRouter()
# @health_router.get("/health")
# async def health_check():
#     return {"status": "healthy"}
